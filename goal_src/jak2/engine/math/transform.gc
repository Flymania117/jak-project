;;-*-Lisp-*-
(in-package goal)

;; name: transform.gc
;; name in dgo: transform
;; dgos: ENGINE, GAME

(defmethod print transform ((obj transform))
  (format #t "#<transform @ #x~X~%" obj)
  (format #t "~T~Ttrans:~F ~F ~F ~F ~%" (-> obj trans x) (-> obj trans y) (-> obj trans z) (-> obj trans w))
  (format #t "~T~Trot:  ~F ~F ~F ~F ~%" (-> obj rot x) (-> obj rot y) (-> obj rot z) (-> obj rot w))
  (format #t "~T~Tscale:~F ~F ~F ~F>" (-> obj scale x) (-> obj scale y) (-> obj scale z) (-> obj scale w))
  obj
  )

(defmethod new trs ((allocation symbol) (type-to-make type))
  (let ((gp-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> gp-0 trans w) 1.0)
    (set! (-> gp-0 rot w) 1.0)
    (vector-identity! (-> gp-0 scale))
    gp-0
    )
  )

(defun transform-matrix-calc! ((arg0 transform) (arg1 matrix))
  (let ((s4-0 (new 'stack-no-clear 'matrix)))
    (set! (-> s4-0 quad 0) (the-as uint128 0))
    (set! (-> s4-0 quad 1) (the-as uint128 0))
    (set! (-> s4-0 quad 2) (the-as uint128 0))
    (set! (-> s4-0 trans quad) (the-as uint128 0))
    (let ((s3-0 (new 'stack-no-clear 'matrix)))
      (set! (-> s3-0 quad 0) (the-as uint128 0))
      (set! (-> s3-0 quad 1) (the-as uint128 0))
      (set! (-> s3-0 quad 2) (the-as uint128 0))
      (set! (-> s3-0 trans quad) (the-as uint128 0))
      (matrix-identity! arg1)
      (matrix-translate! arg1 (-> arg0 trans))
      (matrix-rotate-y! s4-0 (-> arg0 rot y))
      (matrix*! s3-0 s4-0 arg1)
      (matrix-rotate-x! s4-0 (-> arg0 rot x))
      (matrix*! arg1 s4-0 s3-0)
      (matrix-rotate-z! s4-0 (-> arg0 rot z))
      (matrix*! s3-0 s4-0 arg1)
      (matrix-scale! s4-0 (-> arg0 scale))
      (matrix*! arg1 s4-0 s3-0)
      )
    )
  )

(defun transform-matrix-parent-calc! ((arg0 transform) (arg1 matrix) (arg2 vector))
  (let ((s4-0 (new 'stack-no-clear 'matrix)))
    (set! (-> s4-0 quad 0) (the-as uint128 0))
    (set! (-> s4-0 quad 1) (the-as uint128 0))
    (set! (-> s4-0 quad 2) (the-as uint128 0))
    (set! (-> s4-0 trans quad) (the-as uint128 0))
    (let ((s3-0 (new 'stack-no-clear 'matrix)))
      (set! (-> s3-0 quad 0) (the-as uint128 0))
      (set! (-> s3-0 quad 1) (the-as uint128 0))
      (set! (-> s3-0 quad 2) (the-as uint128 0))
      (set! (-> s3-0 trans quad) (the-as uint128 0))
      (matrix-identity! s3-0)
      (matrix-translate! s3-0 (-> arg0 trans))
      (matrix-inv-scale! s4-0 arg2)
      (matrix*! arg1 s4-0 s3-0)
      (matrix-rotate-y! s4-0 (-> arg0 rot y))
      (matrix*! s3-0 s4-0 arg1)
      (matrix-rotate-x! s4-0 (-> arg0 rot x))
      (matrix*! arg1 s4-0 s3-0)
      (matrix-rotate-z! s4-0 (-> arg0 rot z))
      (matrix*! s3-0 s4-0 arg1)
      (matrix-scale! s4-0 (-> arg0 scale))
      (matrix*! arg1 s4-0 s3-0)
      )
    )
  )

(defun trs-matrix-calc! ((arg0 trs) (arg1 matrix))
  (transform-matrix-calc! (the-as transform (-> arg0 trans)) arg1)
  )




